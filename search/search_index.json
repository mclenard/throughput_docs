{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Throughput DB documentation! Throughput DB documentation! \u00b6 This is documentation for the Throughput Database proper. It documents the ways in which the database is built and the node and relationship types within the database.","title":"Home"},{"location":"#throughput-db-documentation","text":"This is documentation for the Throughput Database proper. It documents the ways in which the database is built and the node and relationship types within the database.","title":"Throughput DB documentation!"},{"location":"keywords/keywords/","text":"KEYWORDs \u00b6 A KEYWORD can be associated with any ANNOTATION . A common use would be to help discover an OBJECT associated with a keyword such as climate or cheese . Keywords could be associated with an AGENT or any other node type, but a KEYWORD is always connected through an ANNOTATION . In this way, a KEYWORD may be associated with another KEYWORD through a synonymy which would be represented as indicated below. FIGURE WITH SYNONYMY SYNONYMY \u00b6 Synonymy is indicated by a relationship isSynonym connected by an ANNOTATION . This format allows us to have a TextBody OBJECT that contains information about why the synonymy was generated, and the agent who generated that synonymy. In this case we can match by: MATCH (k:KEYWORD {keyword: $userkw}) OPTIONAL MATCH (syn:KEYWORD)<-[:isSynonym]-(:ANNOTATION)-[:isSynonym]->(k) WITH COLLECT(syn) + COLLECT(k) AS kws MATCH (kws)<-[:hasKeyword]-(:ANNOTATION)-[:Target]->(ob:OBJECT) This will look for all keywords and keyword synonyms, and then find all objects associated with them.","title":"Keywords"},{"location":"keywords/keywords/#keywords","text":"A KEYWORD can be associated with any ANNOTATION . A common use would be to help discover an OBJECT associated with a keyword such as climate or cheese . Keywords could be associated with an AGENT or any other node type, but a KEYWORD is always connected through an ANNOTATION . In this way, a KEYWORD may be associated with another KEYWORD through a synonymy which would be represented as indicated below. FIGURE WITH SYNONYMY","title":"KEYWORDs"},{"location":"keywords/keywords/#synonymy","text":"Synonymy is indicated by a relationship isSynonym connected by an ANNOTATION . This format allows us to have a TextBody OBJECT that contains information about why the synonymy was generated, and the agent who generated that synonymy. In this case we can match by: MATCH (k:KEYWORD {keyword: $userkw}) OPTIONAL MATCH (syn:KEYWORD)<-[:isSynonym]-(:ANNOTATION)-[:isSynonym]->(k) WITH COLLECT(syn) + COLLECT(k) AS kws MATCH (kws)<-[:hasKeyword]-(:ANNOTATION)-[:Target]->(ob:OBJECT) This will look for all keywords and keyword synonyms, and then find all objects associated with them.","title":"SYNONYMY"},{"location":"models/data_models/","text":"Data Models \u00b6 Currently there are several models for relationships within Throughput: Data Use and Reuse Databases linked to code repositories Papers linked to GitHub code repositories Text annotations linked to datasets (linked to databases) Credit tracking Grants linked to databases Grants linked to code repositories Grants linked to papers Data Use and Reuse \u00b6 Throughput aims to help people find ways to use data that meet their needs as a researcher. For example, we want to help early-career researchers find ways to undertake multidisciplinary analysis that combines climate data and information about land use. To do this, a student must find the appropriate data resources and then understand how to undertake analysis on these resources. Data(base)-to-Code Connections \u00b6 A research database may have many uses, through APIs, direct data downloads, or SQL connections to the databases. Throughput links to each repository that uses a particular data resource. This code is publicly available at the Throughput re3 scraper repository . Using schema:DataCatalog OBJECT nodes we can create an annotation that links to a schema:CodeRepository OBJECT . The ANNOTATION node identifies the link between the two records, and can be supplemented with an OBJECT node of TYPE TextualBody . This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE . Sample Query \u00b6 # Search for all code repositories linked to a database: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:\"schema:DataCatalog\"}) WHERE n.name CONTAINS \"searchTerm\" MATCH (o:OBJECT)-[:isType]-(:TYPE {type:\"schema:CodeRepository\"}) WITH n, o MATCH p=(n)-[]-(:ANNOTATION)-[:Target]-(o) RETURN p LIMIT 10 Paper-to-Code Connections \u00b6 Research papers contain detailed methodologies that are supported by peer reviewed literature. This supporting information may be lost when users rely only on the code. By linking code in code repositories to published articles, and the published articles to the code repositories, we make both more discoverable, and provide a clear link, and attribution to the citation itself. Using schema:Article OBJECT nodes we can create an annotation that links to a schema:CodeRepository OBJECT . The ANNOTATION node identifies the link between the two records, and can be supplemented with an OBJECT node of TYPE TextualBody . This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE . Sample Query \u00b6 # Search for all code repositories linked to a database: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:\"schema:Article\"}) WHERE n.doi CONTAINS \"10.1002/ecy.2856\" MATCH (o:OBJECT)-[:isType]-(:TYPE {type:\"schema:CodeRepository\"}) WITH n, o MATCH p=(n)-[]-(:ANNOTATION)-[:Target]-(o) RETURN p LIMIT 10 Text-to-Dataset Connections \u00b6 Research papers contain detailed methodologies that are supported by peer reviewed literature. This supporting information may be lost when users rely only on the code. By linking code in code repositories to published articles, and the published articles to the code repositories, we make both more discoverable, and provide a clear link, and attribution to the citation itself. Using schema:Dataset OBJECT nodes we can create an annotation that links to a TextualBody OBJECT . The ANNOTATION node identifies the link between the two records. This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE . Credit Tracking \u00b6","title":"Data Models"},{"location":"models/data_models/#data-models","text":"Currently there are several models for relationships within Throughput: Data Use and Reuse Databases linked to code repositories Papers linked to GitHub code repositories Text annotations linked to datasets (linked to databases) Credit tracking Grants linked to databases Grants linked to code repositories Grants linked to papers","title":"Data Models"},{"location":"models/data_models/#data-use-and-reuse","text":"Throughput aims to help people find ways to use data that meet their needs as a researcher. For example, we want to help early-career researchers find ways to undertake multidisciplinary analysis that combines climate data and information about land use. To do this, a student must find the appropriate data resources and then understand how to undertake analysis on these resources.","title":"Data Use and Reuse"},{"location":"models/data_models/#database-to-code-connections","text":"A research database may have many uses, through APIs, direct data downloads, or SQL connections to the databases. Throughput links to each repository that uses a particular data resource. This code is publicly available at the Throughput re3 scraper repository . Using schema:DataCatalog OBJECT nodes we can create an annotation that links to a schema:CodeRepository OBJECT . The ANNOTATION node identifies the link between the two records, and can be supplemented with an OBJECT node of TYPE TextualBody . This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE .","title":"Data(base)-to-Code Connections"},{"location":"models/data_models/#sample-query","text":"# Search for all code repositories linked to a database: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:\"schema:DataCatalog\"}) WHERE n.name CONTAINS \"searchTerm\" MATCH (o:OBJECT)-[:isType]-(:TYPE {type:\"schema:CodeRepository\"}) WITH n, o MATCH p=(n)-[]-(:ANNOTATION)-[:Target]-(o) RETURN p LIMIT 10","title":"Sample Query"},{"location":"models/data_models/#paper-to-code-connections","text":"Research papers contain detailed methodologies that are supported by peer reviewed literature. This supporting information may be lost when users rely only on the code. By linking code in code repositories to published articles, and the published articles to the code repositories, we make both more discoverable, and provide a clear link, and attribution to the citation itself. Using schema:Article OBJECT nodes we can create an annotation that links to a schema:CodeRepository OBJECT . The ANNOTATION node identifies the link between the two records, and can be supplemented with an OBJECT node of TYPE TextualBody . This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE .","title":"Paper-to-Code Connections"},{"location":"models/data_models/#sample-query_1","text":"# Search for all code repositories linked to a database: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:\"schema:Article\"}) WHERE n.doi CONTAINS \"10.1002/ecy.2856\" MATCH (o:OBJECT)-[:isType]-(:TYPE {type:\"schema:CodeRepository\"}) WITH n, o MATCH p=(n)-[]-(:ANNOTATION)-[:Target]-(o) RETURN p LIMIT 10","title":"Sample Query"},{"location":"models/data_models/#text-to-dataset-connections","text":"Research papers contain detailed methodologies that are supported by peer reviewed literature. This supporting information may be lost when users rely only on the code. By linking code in code repositories to published articles, and the published articles to the code repositories, we make both more discoverable, and provide a clear link, and attribution to the citation itself. Using schema:Dataset OBJECT nodes we can create an annotation that links to a TextualBody OBJECT . The ANNOTATION node identifies the link between the two records. This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE .","title":"Text-to-Dataset Connections"},{"location":"models/data_models/#credit-tracking","text":"","title":"Credit Tracking"},{"location":"nodes/objects/","text":"OBJECTs \u00b6 Objects are the powerhouse of Throughput. They are the elements that are linked by annotations. The main object classes in Throughput are grants, code repositories and databases. Objects are defined by TYPE classes. A TYPE is defined either through the types defined in the W3C Annotation documentation, or by a set of definitions from schema.org . All objects have a unique ID (imposed by neo4j), and may have a second ID that is defined by the object type. An OBJECT in the database may be connected to a TYPE ( isType ) or an ANNOTATION ( body or target ). TYPEs \u00b6 TYPE is a property of an OBJECT but in practice it is defined as a separate node within the Neo4j database to allow us to improve flexibility of the underlying data model. As such, we can find (for example) a database using: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:'schema:DataCatalog'}) RETURN n LIMIT 3 The TYPE defining an object also defines some of the properties that the object may have, although these are not embedded as constraints. schema:DataCatalog \u00b6 Objects defined as data catalogs were initially scraped from re3data.org using a script that has been stored on GitHub in a code repository <http://https://github.com/throughput-ec/throughputdb/tree/master/Re3Databases> _. The object has properties: id , which come from the unique identifier (DOI) assigned by re3data. name is the official name of the database. url is the URL link for the database. keywords is an array of terms associated with the database (although see keywords ) description is the description given to the database. An object is represented by the cypher statement: (ob:OBJECT {id: \"10.17616/R3PD38\", name: \"Neotoma Paleoecology Database\", url: \"http://neotomadb.org\", keywords: [\"paleoenvironments\", \"fossil mammals (FAUNMAP)\"], description: \"Neotoma is a multiproxy paleoecological database that covers the Pliocene-Quaternary . . .\"}) Individual databases have keywords associated with them. In some cases keywords may be misspelled, or may be either too general (\"science\") or too specific (\"holocene fossils\"). To ensure that keywords can be used effectively we want to add them to the graph. We do this by creating a special node type (KEYWORD), with the constraint that each keyword is unique. Keywords may be related using the :implies relationship. Each KEYWORD is related to an OBJECT through annotations. schema:CodeRepository \u00b6 Objects of type schema:CodeRepository were originally scraped from GitHub, with code that is found in the github_scrapers repository. The objects have the properties: id which is the repository assigned ID (a numeric identifier in the case of GitHub) name The name of the repository is a combination of the repository owner and the repository name. description A user provided description for the repository. url The URL for the repository. MERGE (ob:OBJECT {id: 1234456, url: \"http://github.com/SimonGoring/myrepo\", description: \"This repo is the bomb of bombs.\", name: \"SimonGoring/myrepo\"}) Code repositories may have keywords assigned, or have keywords defined (topics in the terminology of GitHub). These are linked to KEYWORD objects in the database through an ANNOTATION. schema:Article \u00b6 A scientific journal article type is a simplification of the CrossRef data schema v0.1.1 . The schema for OBJECTs of type schema:Article provides fields for journal, title, author, and URL. The field id is used for the DOI, to keep a standard of unique IDs in the id field. id - Unique identifier for grants (assumes NSF grants) journal title author url MERGE (award:OBJECT {\"journal\": \"Risk Analysis\", \"id\": \"10.1111/risa.13567\", \"title\": \"Protecting From Malware Obfuscation Attacks Through Adversarial Risk Analysis\", \"url\": \"https://onlinelibrary.wiley.com/doi/abs/10.1111/risa.13567\", \"authors\": \"Redondo, Alberto; Insua, David R\u00edos\"}) schema:Grant \u00b6 The structure of a grant is (currently) based on the NSF Award schema. The code to obtain the NSF awards and add them to the graph is located within the Throughput database nsf_award module. AwardID - Unique identifier for grants (assumes NSF grants) name amount ARRAAmount AwardInstrument description MERGE (award:OBJECT {AwardID: 1234567, name: \"Award name\", amount: 12345, ARRAAmount: 12345, AwardInstrument = \"Award Thing\", description = \"The abstract of our grant proposal.\"}) Constraints & Indexes \u00b6 Object ids must be unique & are indexed: CREATE CONSTRAINT ON (o:OBJECT) ASSERT o.id IS UNIQUE; CREATE INDEX objName FOR (n:OBJECT) ON (n.name) Object names are indexed CREATE INDEX objName FOR (n:OBJECT) ON (n.name) There is a fulltext index on the name and description : CALL db.index.fulltext.createNodeIndex(\"nameAndDesc\", [\"OBJECT\"], [\"name\", \"description\"])","title":"OBJECTs"},{"location":"nodes/objects/#objects","text":"Objects are the powerhouse of Throughput. They are the elements that are linked by annotations. The main object classes in Throughput are grants, code repositories and databases. Objects are defined by TYPE classes. A TYPE is defined either through the types defined in the W3C Annotation documentation, or by a set of definitions from schema.org . All objects have a unique ID (imposed by neo4j), and may have a second ID that is defined by the object type. An OBJECT in the database may be connected to a TYPE ( isType ) or an ANNOTATION ( body or target ).","title":"OBJECTs"},{"location":"nodes/objects/#types","text":"TYPE is a property of an OBJECT but in practice it is defined as a separate node within the Neo4j database to allow us to improve flexibility of the underlying data model. As such, we can find (for example) a database using: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:'schema:DataCatalog'}) RETURN n LIMIT 3 The TYPE defining an object also defines some of the properties that the object may have, although these are not embedded as constraints.","title":"TYPEs"},{"location":"nodes/objects/#schemadatacatalog","text":"Objects defined as data catalogs were initially scraped from re3data.org using a script that has been stored on GitHub in a code repository <http://https://github.com/throughput-ec/throughputdb/tree/master/Re3Databases> _. The object has properties: id , which come from the unique identifier (DOI) assigned by re3data. name is the official name of the database. url is the URL link for the database. keywords is an array of terms associated with the database (although see keywords ) description is the description given to the database. An object is represented by the cypher statement: (ob:OBJECT {id: \"10.17616/R3PD38\", name: \"Neotoma Paleoecology Database\", url: \"http://neotomadb.org\", keywords: [\"paleoenvironments\", \"fossil mammals (FAUNMAP)\"], description: \"Neotoma is a multiproxy paleoecological database that covers the Pliocene-Quaternary . . .\"}) Individual databases have keywords associated with them. In some cases keywords may be misspelled, or may be either too general (\"science\") or too specific (\"holocene fossils\"). To ensure that keywords can be used effectively we want to add them to the graph. We do this by creating a special node type (KEYWORD), with the constraint that each keyword is unique. Keywords may be related using the :implies relationship. Each KEYWORD is related to an OBJECT through annotations.","title":"schema:DataCatalog"},{"location":"nodes/objects/#schemacoderepository","text":"Objects of type schema:CodeRepository were originally scraped from GitHub, with code that is found in the github_scrapers repository. The objects have the properties: id which is the repository assigned ID (a numeric identifier in the case of GitHub) name The name of the repository is a combination of the repository owner and the repository name. description A user provided description for the repository. url The URL for the repository. MERGE (ob:OBJECT {id: 1234456, url: \"http://github.com/SimonGoring/myrepo\", description: \"This repo is the bomb of bombs.\", name: \"SimonGoring/myrepo\"}) Code repositories may have keywords assigned, or have keywords defined (topics in the terminology of GitHub). These are linked to KEYWORD objects in the database through an ANNOTATION.","title":"schema:CodeRepository"},{"location":"nodes/objects/#schemaarticle","text":"A scientific journal article type is a simplification of the CrossRef data schema v0.1.1 . The schema for OBJECTs of type schema:Article provides fields for journal, title, author, and URL. The field id is used for the DOI, to keep a standard of unique IDs in the id field. id - Unique identifier for grants (assumes NSF grants) journal title author url MERGE (award:OBJECT {\"journal\": \"Risk Analysis\", \"id\": \"10.1111/risa.13567\", \"title\": \"Protecting From Malware Obfuscation Attacks Through Adversarial Risk Analysis\", \"url\": \"https://onlinelibrary.wiley.com/doi/abs/10.1111/risa.13567\", \"authors\": \"Redondo, Alberto; Insua, David R\u00edos\"})","title":"schema:Article"},{"location":"nodes/objects/#schemagrant","text":"The structure of a grant is (currently) based on the NSF Award schema. The code to obtain the NSF awards and add them to the graph is located within the Throughput database nsf_award module. AwardID - Unique identifier for grants (assumes NSF grants) name amount ARRAAmount AwardInstrument description MERGE (award:OBJECT {AwardID: 1234567, name: \"Award name\", amount: 12345, ARRAAmount: 12345, AwardInstrument = \"Award Thing\", description = \"The abstract of our grant proposal.\"})","title":"schema:Grant"},{"location":"nodes/objects/#constraints-indexes","text":"Object ids must be unique & are indexed: CREATE CONSTRAINT ON (o:OBJECT) ASSERT o.id IS UNIQUE; CREATE INDEX objName FOR (n:OBJECT) ON (n.name) Object names are indexed CREATE INDEX objName FOR (n:OBJECT) ON (n.name) There is a fulltext index on the name and description : CALL db.index.fulltext.createNodeIndex(\"nameAndDesc\", [\"OBJECT\"], [\"name\", \"description\"])","title":"Constraints &amp; Indexes"}]}